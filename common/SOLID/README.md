# 객체지향 설계 5대 원칙
객체지향의 5대 원칙은 결국 클래스 내부의 응집도를 높이고, 타 클래스간의 결합도를 낮추는 원칙이다.

## SRP(Single Responsibility Principle) : 단일 책임 원칙
클래스를 설계할 때 추상화를 통해 적절한 멤버변수와 메소드를 정의

해당 클래스의 역할에 적절한 멤버변수와 메소드를 정의해야한다.

하나의 클래스에 모든 멤버변수와 메소드를 정의하는것은 올바르지 못하다.

또한 속성, 메소드, 패키지, 모듈, 컴포넌트, 프래임워크를 단일 원칙의 책임을 주고, 독립적으로 모듈화 시키는 것이 SRP
 
## OCP(Open closed Principle) : 개방 폐쇠 원칙
자신의 확장에는 유연하고 외부의 변화에서는 닫혀있어야한다.

이 의미는 해당 클래스가 확장할때는 아무런 문제가 없고, 다른 클래스가 변화할때 내 클래스가 변하지 않아야 한다는 의미이다.

보통 인터페이스를 이용해 완충역할을 하며, 인터페이스르 통한 다른 클래스들이 변해도 내 자신의 코드를 수정할 필요가 없다.

## LSP(Liskov Substitution Principle) : 리스코브 치환 원칙
Upcasting된 객체는 논리적으로 문제가 없어야한다.

LSP는 인터페이스와 상위클래스 하위클래스를 얼마나 잘 설계했냐가 관건이다.

결론은 하위클래스가 상위클래스의 역할을 대신할때 논리적으로 문제가 없어야한다.

## ISP(Interface Segregation Principle) : 인터페이스 분리 원칙
상황과 관련있는 메소드만 제공해라.

SRP는 너무 많은 책임이 있을경우 여러개의 클래스로 분리한다.

ISP는 클래스를 여러개로 분리하지 않고, 인터페이스를 이용해 상황에 맞는 메소드만 제공하는 원칙이다.

하나의 클래스에서 다양한 인터페이스를 구현해 다양한 기능을 가지지만 필요한 상황에서는 Interface를 참조변수 타입으로 생성해

해당 인터페이스에 맞는 메소드만 제공하는 원칙

## DIP(Dependency Inversion Principle) : 의존 역전 원칙
자신보다 변하기 쉬운것에 의존하지 않고, 추상화된 클래스나 인터페이스를 통해 의존 방향을 바꾸는것이다.

EX) 자동차와 타이어를 생각해 보겠다. 자동차는 쉽게 변하지 않는다. 하지만 타이어는 쉽게 바뀐다. 여러종류의 타이어가 있고, 브랜드별로 타이어가 다를수도있다.
이때 타이어를 interface화 시키고 지금 자동차의 타이어는 타이어의 interface를 구현하는 타이어라면 
타이어의 구현이 바뀌거나 교체되도 자동차의 구현에는 전혀 영향을 미치지 않는다.